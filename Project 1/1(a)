public class SortingAlgo {

    private static long keycomparison = 0;

    public static void main(String[] args) {
        int[] inputArray = {5, 2, 9, 1, 5, 6};
        int start = 0; // Start index of the subarray to be sorted
        int end = inputArray.length - 1; // End index of the subarray to be sorted
        int S = 10; // Threshold value

        // Test the hybridSort method
        hybridSort(inputArray, start, end, S);

        // Verify that the inputArray is sorted correctly
        boolean isSorted = isSorted(inputArray);
        System.out.println("Is the array sorted? " + isSorted);

        // Print the sorted array
        System.out.println("Sorted Array:");
        for (int num : inputArray) {
            System.out.print(num + " ");
        }
    }

    // Helper method to check if an array is sorted
    public static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
        return true;
    }

    // PART A
    // HYBRID SORT ALGORITHM  //
    public static void hybridSort(int[] inputArray, int start, int end, int S) {

        int mid = (start + end) / 2;

        // Insertion Sort
        if (end - start <= 0) return;
        else if (end - start <= S) {
            insertionSort(inputArray, start, end);
        } else if (end - start > 1) {
            // Merge Sort
            if (end > start) {
                hybridSort(inputArray, start, mid, S);
                hybridSort(inputArray, mid + 1, end, S);

            }
        }

        // Commented out since merge doesn't return anything
        // System.out.println(merge(inputArray, start, end));
    }

    // MERGE SORT ALGORITHM //
    public static void mergeSort(int[] inputArray, int start, int end) {

        int mid = (start + end) / 2;

        // Base case
        if (end > start) {
            mergeSort(inputArray, start, mid);
            mergeSort(inputArray, mid + 1, end);
            merge(inputArray, start, end);
        }

    }

    private static void merge(int[] inputArray, int start, int end) {

        int mid = (start + end) / 2;
        int a = start, b = mid + 1, tmp;

        if (end > start) {
            while ((a <= mid) && (b <= end)) {
                keycomparison++;
                // Shifting
                if (inputArray[a] > inputArray[b]) {
                    tmp = inputArray[b++];

                    for (int i = mid; i >= a; i--) {
                        inputArray[i + 1] = inputArray[i];
                    }
                    inputArray[a++] = tmp;
                    mid++;
                }

                // Continue
                else if (inputArray[a] < inputArray[b]) {
                    a++;
                }

                // Same items
                else {

                    // Base case (1 item each subarray)
                    if ((a == mid) && (b == end)) {
                        break;
                    }

                    tmp = inputArray[b++];
                    a++;
                    for (int i = mid; i >= a; i--) {
                        inputArray[i + 1] = inputArray[i];
                    }
                    inputArray[a++] = tmp;
                    mid++;
                }
            }
        }

    }

    // INSERTION SORT ALGORITHM //
    public static void insertionSort(int[] inputArray, int start, int end) {

        for (int i = start + 1; i <= end; i++) {
            for (int j = i; j > start; j--) {

                // Count key comparisons
                keycomparison++;

                if (inputArray[j] < inputArray[j - 1]) {
                    swap(inputArray, j, j - 1);
                } else {
                    break;
                }
            }
        }

    }

    private static void swap(int[] inputArray, int i, int j) {
        int tmp = inputArray[i];
        inputArray[i] = inputArray[j];
        inputArray[j] = tmp;
    }
}
